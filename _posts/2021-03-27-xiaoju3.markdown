---
layout:     post
title:      "小菊的语义分割3🌼——数据预处理及像素级分类实现原理"
subtitle:   " \"数据标签预处理, Softmax进行像素级分类原理\""
date:       2021-03-27 14:00:00
author:     "fuhao7i"
header-img: "img/in-post/xiaoju.jpg"
catalog: true
tags:
    - 小菊的语义分割🌼
---

# 1. 数据预处理

`思路:` 读取train.txt文件，获取训练图像及对应标签的文件路径，读取图像，将图像转化为`tensor`之后，`resize`调整图像尺寸大小并进行`归一化处理`，之后也可通过旋转，色偏，增加噪声等方式进行`数据增强`。注意要保证图像和标签的处理一致。

<img src='https://img-blog.csdnimg.cn/20210327141350996.png' center>

`padding可以使图像在resize时不失真`

**Keras实现**

```python
import numpy as np
from PIL import Image
import keras
from keras import backend as K

# 标签像素值对应的物体类别, 0为背景
CLASSES = {
    '[0 0 0]' : 0, # 背景
    '[1 1 1]' : 1,
    '[2 2 2]' : 2,
}

HEIGHT = 224
WIDTH = 224
N_CLASSES = 3

BATCH_SIZE = 16

# train.txt和val.txt的文件路径
path_train_txt = ''
path_val_txt = ''

# train的图像和标签路径
path_Xtrain = ''
path_Xlabel = ''
# val的图像和标签路径
path_Yval = ''
path_Ylabel = ''

# labels映射
def label_map(labels):
    labelmap = np.zeros([HEIGHT, WIDTH, N_CLASSES])
    for h in range(HEIGHT):
        for w in range(WIDTH):
            labelmap[h, w, str(labels[h, w])] = 1
    return labelmap


def data_generator(lines, mode):
    assert mode in ['train', 'val'], \
        'mode must be ethier \'train\' or \'val\''

    n = len(lines)

    if mode == 'train':
        with open(path_train_txt, 'r') as f:
            lines = f.readlines()
        np.random.shuffle(lines)

        path0 = path_Xtrian
        path1 = path_Xlabel
    else:
        with open(path_val_txt, 'r') as f:
            lines = f.readlines()
        np.random.shuffle(lines)

        path0 = path_Yval
        path1 = path_Ylabel 

    while 1:
        data = []
        label = []
        for _ in range(BATCH_SIZE):
            if i == 0: 
                np.random.shuffle(lines)
            name = lines[i].split(';')[0]
            img = Image.open(path0 + '/' + name)
            img = img.resize((HEIGHT, WIDTH))
            img = np.array(img)
            img = img/255.
            data.append(img)

            name = (lines[i].split(';')[1]).replace("\n", "")
            img = Image.open(path1 + '/' + name)
            img = img.resize((HEIGHT, WIDTH))
            img = np.array(img)
            seg_labels = label_map(img)

            seg_labels = np.reshape(seg_labels, (-1,N_CLASSES))

            label.append(seg_labels)

            i = (i+1) % n

            # yield 的作用就是把一个函数变成一个 generator
        yield (np.array(data), np.array(label))

# 定义损失函数
def loss(y_true, y_pred):
    crossloss = K.binary_crossentropy(y_true,y_pred)
    loss = K.sum(crossloss)/HEIGHT/WIDTH

int main():
    
    # 用于最后保存模型的路径
    log_dir = ''

    # 创建模型
    model = Net()

    # 获取训练样本和验证样本的数目
    with open(path_train_txt, 'r') as f:
        lines = f.readlines()
    num_train = len(lines)
    with open(path_val_txt, 'r') as f:
        lines = f.readlines()
    num_val = len(lines)


    # 设置学习率下降方法,val_loss验证损失连续5个epoch不下降就让学习率减半
    reduce_lr = ReduceLROnPlateau(
                            monitor='val_loss', 
                            factor=0.5, 
                            patience=5, 
                            verbose=1
                        )
    # 是否需要早停，当val_loss一直不下降的时候意味着模型基本训练完毕，可以停止
    early_stopping = EarlyStopping(
                            monitor='val_loss', 
                            min_delta=0, 
                            patience=10, 
                            verbose=1
                        )
    # 设置损失，优化器
    model.compile(loss = loss,
            optimizer = Adam(lr=1e-3),
            metrics = ['accuracy'])

    print('Train on {} samples, val on {} samples, with batch size {}.'.format(num_train, num_val, BATCH_SIZE))

    # 开始训练
    model.fit_generator(data_generator('train'),
            steps_per_epoch=max(1, num_train//batch_size),
            validation_data=data_generator('val'),
            validation_steps=max(1, num_val//batch_size),
            epochs=50,
            initial_epoch=0,
            callbacks=[reduce_lr, early_stopping])

    model.save_weights(log_dir+'Dali.h5')


```

**PyTorch实现**

