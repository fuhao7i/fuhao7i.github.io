---
layout:     post
title:      "å°èŠçš„è¯­ä¹‰åˆ†å‰²3ğŸŒ¼â€”â€”æ•°æ®é¢„å¤„ç†åŠåƒç´ çº§åˆ†ç±»å®ç°åŸç†"
subtitle:   " \"æ•°æ®æ ‡ç­¾é¢„å¤„ç†, Softmaxè¿›è¡Œåƒç´ çº§åˆ†ç±»åŸç†\""
date:       2021-03-27 14:00:00
author:     "fuhao7i"
header-img: "img/in-post/xiaoju.jpg"
catalog: true
tags:
    - å°èŠçš„è¯­ä¹‰åˆ†å‰²ğŸŒ¼
---

# 1. æ•°æ®é¢„å¤„ç†

`æ€è·¯:` è¯»å–train.txtæ–‡ä»¶ï¼Œè·å–è®­ç»ƒå›¾åƒåŠå¯¹åº”æ ‡ç­¾çš„æ–‡ä»¶è·¯å¾„ï¼Œè¯»å–å›¾åƒï¼Œå°†å›¾åƒè½¬åŒ–ä¸º`tensor`ä¹‹åï¼Œ`resize`è°ƒæ•´å›¾åƒå°ºå¯¸å¤§å°å¹¶è¿›è¡Œ`å½’ä¸€åŒ–å¤„ç†`ï¼Œä¹‹åä¹Ÿå¯é€šè¿‡æ—‹è½¬ï¼Œè‰²åï¼Œå¢åŠ å™ªå£°ç­‰æ–¹å¼è¿›è¡Œ`æ•°æ®å¢å¼º`ã€‚æ³¨æ„è¦ä¿è¯å›¾åƒå’Œæ ‡ç­¾çš„å¤„ç†ä¸€è‡´ã€‚

<img src='https://img-blog.csdnimg.cn/20210327141350996.png' center>

`paddingå¯ä»¥ä½¿å›¾åƒåœ¨resizeæ—¶ä¸å¤±çœŸ`

**Keraså®ç°**

```python
import numpy as np
from PIL import Image
import keras
from keras import backend as K

# æ ‡ç­¾åƒç´ å€¼å¯¹åº”çš„ç‰©ä½“ç±»åˆ«, 0ä¸ºèƒŒæ™¯
CLASSES = {
    '[0 0 0]' : 0, # èƒŒæ™¯
    '[1 1 1]' : 1,
    '[2 2 2]' : 2,
}

HEIGHT = 224
WIDTH = 224
N_CLASSES = 3

BATCH_SIZE = 16

# train.txtå’Œval.txtçš„æ–‡ä»¶è·¯å¾„
path_train_txt = ''
path_val_txt = ''

# trainçš„å›¾åƒå’Œæ ‡ç­¾è·¯å¾„
path_Xtrain = ''
path_Xlabel = ''
# valçš„å›¾åƒå’Œæ ‡ç­¾è·¯å¾„
path_Yval = ''
path_Ylabel = ''

# labelsæ˜ å°„
def label_map(labels):
    labelmap = np.zeros([HEIGHT, WIDTH, N_CLASSES])
    for h in range(HEIGHT):
        for w in range(WIDTH):
            labelmap[h, w, str(labels[h, w])] = 1
    return labelmap


def data_generator(lines, mode):
    assert mode in ['train', 'val'], \
        'mode must be ethier \'train\' or \'val\''

    n = len(lines)

    if mode == 'train':
        with open(path_train_txt, 'r') as f:
            lines = f.readlines()
        np.random.shuffle(lines)

        path0 = path_Xtrian
        path1 = path_Xlabel
    else:
        with open(path_val_txt, 'r') as f:
            lines = f.readlines()
        np.random.shuffle(lines)

        path0 = path_Yval
        path1 = path_Ylabel 

    while 1:
        data = []
        label = []
        for _ in range(BATCH_SIZE):
            if i == 0: 
                np.random.shuffle(lines)
            name = lines[i].split(';')[0]
            img = Image.open(path0 + '/' + name)
            img = img.resize((HEIGHT, WIDTH))
            img = np.array(img)
            img = img/255.
            data.append(img)

            name = (lines[i].split(';')[1]).replace("\n", "")
            img = Image.open(path1 + '/' + name)
            img = img.resize((HEIGHT, WIDTH))
            img = np.array(img)
            seg_labels = label_map(img)

            seg_labels = np.reshape(seg_labels, (-1,N_CLASSES))

            label.append(seg_labels)

            i = (i+1) % n

            # yield çš„ä½œç”¨å°±æ˜¯æŠŠä¸€ä¸ªå‡½æ•°å˜æˆä¸€ä¸ª generator
        yield (np.array(data), np.array(label))

# å®šä¹‰æŸå¤±å‡½æ•°
def loss(y_true, y_pred):
    crossloss = K.binary_crossentropy(y_true,y_pred)
    loss = K.sum(crossloss)/HEIGHT/WIDTH

int main():
    
    # ç”¨äºæœ€åä¿å­˜æ¨¡å‹çš„è·¯å¾„
    log_dir = ''

    # åˆ›å»ºæ¨¡å‹
    model = Net()

    # è·å–è®­ç»ƒæ ·æœ¬å’ŒéªŒè¯æ ·æœ¬çš„æ•°ç›®
    with open(path_train_txt, 'r') as f:
        lines = f.readlines()
    num_train = len(lines)
    with open(path_val_txt, 'r') as f:
        lines = f.readlines()
    num_val = len(lines)


    # è®¾ç½®å­¦ä¹ ç‡ä¸‹é™æ–¹æ³•,val_losséªŒè¯æŸå¤±è¿ç»­5ä¸ªepochä¸ä¸‹é™å°±è®©å­¦ä¹ ç‡å‡åŠ
    reduce_lr = ReduceLROnPlateau(
                            monitor='val_loss', 
                            factor=0.5, 
                            patience=5, 
                            verbose=1
                        )
    # æ˜¯å¦éœ€è¦æ—©åœï¼Œå½“val_lossä¸€ç›´ä¸ä¸‹é™çš„æ—¶å€™æ„å‘³ç€æ¨¡å‹åŸºæœ¬è®­ç»ƒå®Œæ¯•ï¼Œå¯ä»¥åœæ­¢
    early_stopping = EarlyStopping(
                            monitor='val_loss', 
                            min_delta=0, 
                            patience=10, 
                            verbose=1
                        )
    # è®¾ç½®æŸå¤±ï¼Œä¼˜åŒ–å™¨
    model.compile(loss = loss,
            optimizer = Adam(lr=1e-3),
            metrics = ['accuracy'])

    print('Train on {} samples, val on {} samples, with batch size {}.'.format(num_train, num_val, BATCH_SIZE))

    # å¼€å§‹è®­ç»ƒ
    model.fit_generator(data_generator('train'),
            steps_per_epoch=max(1, num_train//batch_size),
            validation_data=data_generator('val'),
            validation_steps=max(1, num_val//batch_size),
            epochs=50,
            initial_epoch=0,
            callbacks=[reduce_lr, early_stopping])

    model.save_weights(log_dir+'Dali.h5')


```

**PyTorchå®ç°**

